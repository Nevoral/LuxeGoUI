// Package tags do not edit, this file was autogenerated.
package tags

import (
	"fmt"
	spec "github.com/Nevoral/LuxeGoUI/Specification"
)

func AHtml(tags []any) *ATagHtml {
	node := &ATagHtml{
		tag: &tag{
			name:                "a",
			attributes:          nil,
			supportedAttributes: nil,
			tagType:             spec.FullTagType,
			namespace:           spec.HTML,
			children:            nil,
			textContent:         "",
			parent:              nil,
			nestingLevel:        0,
			renderFormat:        DefaultHtml,
		},
	}
	return node.supportedChildrenCheck(tags)
}

type ATagHtml struct {
	*tag
}

/*
************************************************************************************************************************
*-------------------------------------------------- Extension Method --------------------------------------------------*
************************************************************************************************************************
 */

/*
CustomAttribute - This is method for adding custom attribute, that are not in HTML5 specification.
*/
func (a *ATagHtml) CustomAttribute(attributes ...*Attribute) *ATagHtml {
	a.registerAttributes(attributes...)
	return a
}

/*
Children - Method for nesting tags into parent tag
*/
func (a *ATagHtml) Children(tags ...any) *ATagHtml {
	return a.supportedChildrenCheck(tags)
}

func (a *ATagHtml) supportedChildrenCheck(tags []any) *ATagHtml {
	for _, tagObj := range tags {
		switch val := tagObj.(type) {
		case string:
			a.registerChildren(TextContentSvg(val).getTag())
		case content:
			a.registerChildren(val.getTag())
		case []content:
			for _, child := range val {
				a.registerChildren(child.getTag())
			}
		default:
			panic(fmt.Sprintf("Unsupported content type. %v", val))
		}
	}
	return a
}

/*
************************************************************************************************************************
*------------------------------------------------ Specific Attributes -------------------------------------------------*
************************************************************************************************************************
 */

/*
Download - Causes the browser to treat the linked URL as a download. Can be used with or without a filename value:
Causes the browser to treat the linked URL as a download. Can be used with or without a filename value:

	    Without a value, the browser will suggest a filename/extension, generated from various sources:
	        The Content-Disposition HTTP header
	        The final segment in the URL path
	        The media type (from the Content-Type header, the start of a data: URL, or Blob.type for a blob: URL)
	    filename: defining a value suggests it as the filename. / and \ characters are converted to underscores (_). Filesystems may forbid other characters in filenames, so browsers will adjust the suggested name if necessary.

	Note:

	    download only works for same-origin URLs, or the blob: and data: schemes.
	    How browsers treat downloads varies by browser, user settings, and other factors. The user may be prompted before a download starts, or the file may be saved automatically, or it may open automatically, either in an external application or in the browser itself.
	    If the Content-Disposition header has different information from the download attribute, resulting behavior may differ:
	        If the header specifies a filename, it takes priority over a filename specified in the download attribute.
	        If the header specifies a disposition of inline, Chrome and Firefox prioritize the attribute and treat it as a download. Old Firefox versions (before 82) prioritize the header and will display the content inline.
*/
func (a *ATagHtml) Download(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("download", value)
	return a
}

/*
Href - The URL that the hyperlink points to. Links are not restricted to HTTP-based URLs — they can use any URL scheme supported by browsers:
The URL that the hyperlink points to. Links are not restricted to HTTP-based URLs — they can use any URL scheme supported by browsers:

	Sections of a page with document fragments
	Specific text portions with text fragments
	Pieces of media files with media fragments
	Telephone numbers with tel: URLs
	Email addresses with mailto: URLs
	SMS text messages with sms: URLs
	While web browsers may not support other URL schemes, websites can with registerProtocolHandler()
*/
func (a *ATagHtml) Href(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("href", value)
	return a
}

/*
Hreflang - Hints at the human language of the linked URL. No built-in functionality. Allowed values are the same as the global lang attribute.
Hints at the human language of the linked URL. No built-in functionality. Allowed values are the same as the global lang attribute.
*/
func (a *ATagHtml) Hreflang(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("hreflang", value)
	return a
}

/*
Ping - A space-separated list of URLs. When the link is followed, the browser will send POST requests with the body PING to the URLs. Typically for tracking.
A space-separated list of URLs. When the link is followed, the browser will send POST requests with the body PING to the URLs. Typically for tracking.
*/
func (a *ATagHtml) Ping(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("ping", value)
	return a
}

/*
Referrerpolicy - How much of the referrer to send when following the link.
How much of the referrer to send when following the link.

	no-referrer: The Referer header will not be sent.
	no-referrer-when-downgrade: The Referer header will not be sent to origins without TLS (HTTPS).
	origin: The sent referrer will be limited to the origin of the referring page: its scheme, host, and port.
	origin-when-cross-origin: The referrer sent to other origins will be limited to the scheme, the host, and the port. Navigations on the same origin will still include the path.
	same-origin: A referrer will be sent for same origin, but cross-origin requests will contain no referrer information.
	strict-origin: Only send the origin of the document as the referrer when the protocol security level stays the same (HTTPS→HTTPS), but don't send it to a less secure destination (HTTPS→HTTP).
	strict-origin-when-cross-origin (default): Send a full URL when performing a same-origin request, only send the origin when the protocol security level stays the same (HTTPS→HTTPS), and send no header to a less secure destination (HTTPS→HTTP).
	unsafe-url: The referrer will include the origin and the path (but not the fragment, password, or username). This value is unsafe, because it leaks origins and paths from TLS-protected resources to insecure origins.
*/
func (a *ATagHtml) Referrerpolicy(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("referrerpolicy", value)
	return a
}

/*
Rel - The relationship of the linked URL as space-separated link types.
The relationship of the linked URL as space-separated link types.
*/
func (a *ATagHtml) Rel(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("rel", value)
	return a
}

/*
Target - Where to display the linked URL, as the name for a browsing context (a tab, window, or <iframe>). The following keywords have special meanings for where to load the URL:
Where to display the linked URL, as the name for a browsing context (a tab, window, or <iframe>). The following keywords have special meanings for where to load the URL:

	    _self: The current browsing context. (Default)
	    _blank: Usually a new tab, but users can configure browsers to open a new window instead.
	    _parent: The parent browsing context of the current one. If no parent, behaves as _self.
	    _top: The topmost browsing context. To be specific, this means the "highest" context that's an ancestor of the current one. If no ancestors, behaves as _self.
	    _unfencedTop: Allows embedded fenced frames to navigate the top-level frame (i.e. traversing beyond the root of the fenced frame, unlike other reserved destinations). Note that the navigation will still succeed if this is used outside of a fenced frame context, but it will not act like a reserved keyword.

	Note: Setting target="_blank" on <a> elements implicitly provides the same rel behavior as setting rel="noopener" which does not set window.opener.
*/
func (a *ATagHtml) Target(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("target", value)
	return a
}

/*
Type - Hints at the linked URL's format with a MIME type. No built-in functionality.
Hints at the linked URL's format with a MIME type. No built-in functionality.
*/
func (a *ATagHtml) Type(value string) *ATagHtml {
	if a.attributes == nil {
		a.attributes = []*Attribute{}
	}
	a.registerAttribute("type", value)
	return a
}
